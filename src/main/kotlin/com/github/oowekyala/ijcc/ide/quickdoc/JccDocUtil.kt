package com.github.oowekyala.ijcc.ide.quickdoc

import com.github.oowekyala.ijcc.lang.model.Token
import com.github.oowekyala.ijcc.lang.psi.getProductionByName
import com.github.oowekyala.ijcc.lang.psi.JccFile
import com.github.oowekyala.ijcc.lang.psi.JccNonTerminalProduction
import com.intellij.codeInsight.documentation.DocumentationManager
import com.intellij.codeInsight.documentation.DocumentationManagerProtocol
import com.intellij.codeInsight.javadoc.JavaDocUtil
import com.intellij.lang.documentation.DocumentationMarkup.*
import com.intellij.openapi.util.Key
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiManager
import com.intellij.psi.impl.FakePsiElement
import org.intellij.lang.annotations.Language
import org.jetbrains.annotations.TestOnly

/**
 * Utilities to build the quickdoc.
 *
 * @author ClÃ©ment Fournier
 * @since 1.0
 */
object JccDocUtil {

    private const val TerminalRef = "token"
    private const val LexStateRef = "lexstate"
    private const val StringTokenRef = "strToken"
    private const val NonterminalRef = "nonterminal"

    /** Finds the target of a link created by [linkRefToLexicalState]. */
    fun findLinkTarget(psiManager: PsiManager?, ref: String?, context: PsiElement?): PsiElement? {
        ref ?: return null

        if (ref.contains('/')) {
            // the link was generated by this object

            val psiFile = context?.containingFile as? JccFile ?: return null
            val (type, name) = ref.split("/")


            return when (type) {
                LexStateRef    ->
                    psiFile.lexicalGrammar.getLexicalState(name)?.declarationIdent ?: psiFile.fakeDefaultStateDecl
                StringTokenRef -> psiFile.lexicalGrammar.allTokens.getOrNull(name.toInt())?.psiElement
                TerminalRef    -> psiFile.lexicalGrammar.getTokenByName(name)?.psiElement
                NonterminalRef -> psiFile.getProductionByName(name)
                else           -> null
            }
        } else {
            // probably generated by [JavaDocUtil]

            return JavaDocUtil.findReferenceTarget(psiManager, ref, context)
        }
    }

    @TestOnly
    fun linkRefToStringToken(i: Int) = "$StringTokenRef/$i"

    /** Gets a hyperlink suitable for use with [HtmlUtil.psiLink]. */
    fun linkRefToToken(spec: Token): String? = when {
        spec.name != null -> "$TerminalRef/${spec.name}"
        else              ->
            spec.psiElement
                ?.containingFile
                ?.lexicalGrammar
                ?.allTokens
                ?.indexOf(spec)
                ?.let { "$StringTokenRef/$it" }
    }

    /** Gets a hyperlink suitable for use with [HtmlUtil.psiLink]. */
    fun linkRefToLexicalState(lexicalStateName: String): String = "$LexStateRef/$lexicalStateName"

    /** Gets a hyperlink suitable for use with [HtmlUtil.psiLink]. */
    fun linkRefToProd(production: JccNonTerminalProduction): String = "$NonterminalRef/${production.name}"


    /** Builds a quickdoc using a DSL, hiding most HTML formatting away. */
    fun buildQuickDoc(spec: DocBuilder.() -> Unit): String = StringBuilder().also { DocBuilder(it).spec() }.toString()

    class DocBuilder(private val stringBuilder: StringBuilder) {

        fun definition(defContents: () -> String): Unit =
            buildDefinition {
                append(defContents())
            }


        fun buildDefinition(defContents: java.lang.StringBuilder.() -> Unit) {
            stringBuilder.append(DEFINITION_START)
            stringBuilder.defContents()
            stringBuilder.append(DEFINITION_END).append("\n")
        }

        fun sections(sectionDefs: SectionsBuilder.() -> Unit) {
            stringBuilder.append(SECTIONS_START)
            SectionsBuilder(stringBuilder).sectionDefs()
            stringBuilder.append(SECTIONS_END)
        }

    }

    class SectionsBuilder(private val stringBuilder: StringBuilder) {

        fun emptySection(header: String): Unit = buildSection(header, sectionDelim = "") { }

        fun section(header: String, sectionDelim: String = ":", body: () -> String): Unit =
            buildSection(header, sectionDelim) {
                append(body())
            }

        fun buildSection(header: String, sectionDelim: String = ":", body: java.lang.StringBuilder.() -> Unit) {
            stringBuilder.append(SECTION_HEADER_START)
            stringBuilder.append(header).append(sectionDelim)
            stringBuilder.append(SECTION_SEPARATOR).append("<p>")
            stringBuilder.body()
            stringBuilder.append(SECTION_END).append("\n")
        }
    }
}


object HtmlUtil {

    val br = "<br/>"

    @Language("HTML")
    fun emph(it: String) = "<i>$it</i>"

    @Language("HTML")
    fun bold(it: String) = "<b>$it</b>"

    @Language("HTML")
    fun angles(it: String) = "&lt;$it&gt;"

    @Language("HTML")
    fun code(it: String) = "<code>$it</code>"

    @Language("HTML")
    fun pre(it: String) = "<pre>$it</pre>"

    @Language("HTML")
    fun link(target: String, text: String) = "<a href=\"$target\">$text</a>"

    /**
     * Kotlin wrapper around [DocumentationManager.createHyperlink]
     * @param isCodeLink Whether the [linkText] should be wrapped into `<code>` tags
     */
    @Language("HTML")
    fun psiLink(builder: StringBuilder = StringBuilder(),
                linkTarget: String?,
                @Language("HTML") linkText: String,
                isCodeLink: Boolean = true) {
        createHyperlinkImpl(buffer = builder, label = linkText, refText = linkTarget, plainLink = !isCodeLink)
    }

    // copy pasted from DocumentationManagerUtil because the component service cannot be
    // created during tests..
    private fun createHyperlinkImpl(buffer: StringBuilder,
                                    refText: String?,
                                    label: String,
                                    plainLink: Boolean) {
        buffer.append("<a href=\"")
        buffer.append(DocumentationManagerProtocol.PSI_ELEMENT_PROTOCOL) // :-)
        buffer.append(refText)
        buffer.append("\">")
        if (!plainLink) {
            buffer.append("<code>")
        }
        buffer.append(label)
        if (!plainLink) {
            buffer.append("</code>")
        }
        buffer.append("</a>")
    }

    @Language("HTML")
    fun psiLink(linkTarget: String?,
                @Language("HTML") linkText: String,
                isCodeLink: Boolean = true): String =
        StringBuilder().also { psiLink(it, linkTarget, linkText, isCodeLink) }.toString()
}


private val FakeDefaultStateEltKey = Key.create<PsiElement>("jcc.fake.default.state")

val JccFile.fakeDefaultStateDecl: PsiElement
    get() = getUserData(FakeDefaultStateEltKey)
        ?: let {
            val fake = object : FakePsiElement() {
                override fun getParent(): PsiElement = this@fakeDefaultStateDecl
            }
            putUserData(FakeDefaultStateEltKey, fake)

            return fake
        }