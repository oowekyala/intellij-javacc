package com.github.oowekyala.ijcc.ide.quickdoc

import com.github.oowekyala.ijcc.lang.psi.JccFile
import com.github.oowekyala.ijcc.lang.psi.JccNonTerminalProduction
import com.github.oowekyala.ijcc.lang.psi.JccRegexprSpec
import com.intellij.codeInsight.documentation.DocumentationManager
import com.intellij.codeInsight.documentation.DocumentationManagerProtocol
import com.intellij.codeInsight.javadoc.JavaDocUtil
import com.intellij.lang.documentation.DocumentationMarkup.*
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiManager
import org.intellij.lang.annotations.Language

/**
 * Utilities to build the quickdoc.
 *
 * @author ClÃ©ment Fournier
 * @since 1.0
 */
object JccDocUtil {

    private const val TerminalRef = "token"
    private const val NonterminalRef = "nonterminal"


    /** Finds the target of a link created by [getLinkRefTo]. */
    @Suppress("UNUSED_PARAMETER")
    fun findLinkTarget(psiManager: PsiManager?, ref: String?, context: PsiElement?): PsiElement? {
        ref ?: return null

        if (ref.contains('/')) {
            // the link was generated by this object

            val psiFile = context?.containingFile as? JccFile ?: return null
            val (type, name) = ref.split("/")

            return when (type) {
                TerminalRef    -> psiFile.globalNamedTokens
                NonterminalRef -> psiFile.nonTerminalProductions
                else           -> emptySequence()
            }.filter { it.name == name }.firstOrNull()
        } else {
            // probably generated by [JavaDocUtil]

            return JavaDocUtil.findReferenceTarget(psiManager, ref, context)

        }

    }

    /** Gets a hyperlink suitable for use with [DocumentationManager.createHyperlink]. */
    fun getLinkRefTo(spec: JccRegexprSpec): String = "$TerminalRef/${spec.name}"

    /** Gets a hyperlink suitable for use with [DocumentationManager.createHyperlink]. */
    fun getLinkRefTo(production: JccNonTerminalProduction): String = "$NonterminalRef/${production.name}"


    /** Builds a quickdoc using a DSL, hiding most HTML formatting away. */
    fun buildQuickDoc(spec: DocBuilder.() -> Unit): String = StringBuilder().also { DocBuilder(it).spec() }.toString()

    class DocBuilder(private val stringBuilder: StringBuilder) {

        fun definition(defContents: () -> String) =
                buildDefinition {
                    append(defContents())
                }


        fun buildDefinition(defContents: java.lang.StringBuilder.() -> Unit) {
            stringBuilder.append(DEFINITION_START)
            stringBuilder.defContents()
            stringBuilder.append(DEFINITION_END).append("\n")
        }

        fun sections(sectionDefs: SectionsBuilder.() -> Unit) {
            stringBuilder.append(SECTIONS_START)
            SectionsBuilder(stringBuilder).sectionDefs()
            stringBuilder.append(SECTIONS_END)
        }

    }

    class SectionsBuilder(private val stringBuilder: StringBuilder) {

        fun emptySection(header: String) = buildSection(header, sectionDelim = "") { }

        fun section(header: String, sectionDelim: String = ":", body: () -> String) =
                buildSection(header, sectionDelim) {
                    append(body())
                }

        fun buildSection(header: String, sectionDelim: String = ":", body: java.lang.StringBuilder.() -> Unit) {
            stringBuilder.append(SECTION_HEADER_START)
            stringBuilder.append(header).append(sectionDelim)
            stringBuilder.append(SECTION_SEPARATOR).append("<p>")
            stringBuilder.body()
            stringBuilder.append(SECTION_END).append("\n")
        }
    }
}


object HtmlUtil {

    val br = "<br/>"

    @Language("HTML")
    fun emph(it: String) = "<i>$it</i>"

    @Language("HTML")
    fun bold(it: String) = "<b>$it</b>"

    @Language("HTML")
    fun angles(it: String) = "&lt;$it&gt;"

    @Language("HTML")
    fun code(it: String) = "<code>$it</code>"

    @Language("HTML")
    fun pre(it: String) = "<pre>$it</pre>"

    @Language("HTML")
    fun link(target: String, text: String) = "<a href=\"$target\">$text</a>"

    @Language("HTML")
    fun psiLink(target: String, @Language("HTML") text: String, codeLink: Boolean = true) =
            (if (codeLink) code(text) else text).let {
                "<a href=\"${DocumentationManagerProtocol.PSI_ELEMENT_PROTOCOL}$target\">$it</a>"
            }

}