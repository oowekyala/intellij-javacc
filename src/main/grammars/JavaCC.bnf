{
  parserClass="com.github.oowekyala.ijcc.lang.parser.JavaccParser"
  parserUtilClass="com.github.oowekyala.ijcc.lang.parser.JavaccParserUtil"

  implements="com.github.oowekyala.ijcc.lang.psi.JavaccPsiElement"
  extends="com.github.oowekyala.ijcc.lang.psi.impl.JavaccPsiElementImpl"

  elementTypeHolderClass="com.github.oowekyala.ijcc.lang.JavaccTypes"
  elementTypePrefix="JCC_"
  elementTypeClass="com.github.oowekyala.ijcc.lang.psi.IJavaccElementType"
  tokenTypeClass="com.github.oowekyala.ijcc.lang.psi.IJavaccTokenType"

  psiClassPrefix="Jcc"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.oowekyala.ijcc.lang.psi"
  psiImplPackage="com.github.oowekyala.ijcc.lang.psi.impl"

  // not on the classpath...
  psiImplUtilClass="com.github.oowekyala.ijcc.lang.psi.impl.JavaccPsiImplUtil"

  generate=[java="8"]

  parserImports = [
  'static com.intellij.psi.JavaTokenType.*'
  ]

  generatePsi=true
  tokens = [
        LOOKAHEAD_KEYWORD         = 'LOOKAHEAD'
        IGNORE_CASE_OPTION        = 'IGNORE_CASE'
        PARSER_BEGIN_KEYWORD      = 'PARSER_BEGIN'
        PARSER_END_KEYWORD        = 'PARSER_END'
        JAVACODE_KEYWORD          = 'JAVACODE'
        TOKEN_KEYWORD             = 'TOKEN'
        SPECIAL_TOKEN_KEYWORD     = 'SPECIAL_TOKEN'
        MORE_KEYWORD              = 'MORE'
        SKIP_KEYWORD              = 'SKIP'
        TOKEN_MGR_DECLS_KEYWORD   = 'TOKEN_MGR_DECLS'
        EOF_KEYWORD               = 'EOF'


  		PRIVATE_KEYWORD		= "private"
  		PUBLIC_KEYWORD		= "public"
  		PROTECTED_KEYWORD	= "protected"

  		STATIC_KEYWORD	= "static"

  		VOID_KEYWORD	= "void"

  		FALSE_KEYWORD	= "false"
  		TRUE_KEYWORD	= "true"

  		THROWS_KEYWORD	= "throws"
  		TRY_KEYWORD	    = "try"
  		CATCH_KEYWORD	= "catch"
  		FINALLY_KEYWORD	= "finally"

        IDENT       = 'regexp:\p{Alpha}\w*'

        POUND       = "#"
        COLON       = ":"

        LT          = "<"
        GT          = ">"

  		LPARENTH	= "("
  		RPARENTH	= ")"
  		LBRACE		= "{"
  		RBRACE		= "}"
        LBRACKET    = "["
        RBRACKET    = "]"

  		SEMICOLON	= ";"
  		COMMA	    = ","
  		ELLIPSIS    = "..."
  		DOT         = "."

        EQ          = "="

  		UNION       = "|"
  		TILDE       = "~"
        ASTERISK    = "*"
        PLUS        = "+"
        MINUS       = "-"
        QUESTION    = "?"

        DOUBLE_LITERAL      = 'regexp:(0[xb])?[\da-fA-F]*(\.[\da-fA-F]+)?[dD]?'
        INTEGER_LITERAL     = 'regexp:(0[xb])?[\da-fA-F]+'
        STRING_LITERAL      = 'regexp:"([^"\\]|\\.)*"'
        FLOAT_LITERAL       = 'regexp:(0[xb])?[\da-fA-F]*(\.[\da-fA-F]+)?[fF]?'
        LONG_LITERAL        = 'regexp:(0[xb])?[\da-fA-F]+[lL]'
        CHARACTER_LITERAL   = "regexp:'([^\\\'\r\n]|\\[^\n\r])'"

        C_STYLE_COMMENT     = "C_STYLE_COMMENT"
        END_OF_LINE_COMMENT = "END_OF_LINE_COMMENT"
        DOC_COMMENT         = "DOC_COMMENT"

        BAD_CHARACTER   = "BAD_CHARACTER"
  ]

  implements("(bnf|javacode)_production") = 'com.github.oowekyala.ijcc.lang.psi.JccNonTerminalProduction'

  implements("(bnf|javacode)_production") = non_terminal_production
  methods("(bnf|javacode)_production") = [header="java_non_terminal_production_header"]

  implements("(bnf|javacode)_production|.*production_header|jjtree_node_descriptor|named_regular_expression|regular_expression_reference|non_terminal_expansion_unit|option_binding")=identifier_owner

  methods(".*production_header|jjtree_node_descriptor|named_regular_expression|regular_expression_reference|non_terminal_expansion_unit|option_binding") = [
    nameIdentifier="identifier"
  ]

  methods("jjtree_node_descriptor") = [descriptorExpr="jjtree_node_descriptor_expr"]

  consumeTokenMethod(".*_regexp_.*")="consumeTokenFast"

  extends("literal_regular_expression|regular_expression_reference|character_list|parenthesized_regexp_unit")=regexp_unit
  extends("regexp_sequence|regexp_unit|regexp_alternative")=regexp_element
  extends("regular_expression_.+|.+_regular_expression")=regular_expression
  implements("regular_expression|regexp_element")=regexp_like

  implements("literal_regular_expression|regular_expression_reference")=regular_expression

  extends(".*_expansion_unit|regular_expression|parser_actions_unit|local_lookahead")=expansion_unit
  extends("expansion_(alternative|sequence|unit)")=expansion

  extends("one_or_more|zero_or_more|zero_or_one")=occurrence_indicator
  implements("repetition_range|occurence_indicator")=occurrence_indicator_or_range
}

javacc_input 	::=
    option_section?
	parser_declaration
	( production )*

option_section 	    ::=
    "options" "{" ( option_binding )* "}" {pin=1}

option_binding 	    ::=
    option_name "=" (INTEGER_LITERAL | string_literal | boolean_literal) ";" {pin=1 recoverWhile="#auto"}

private option_name ::=
        "LOOKAHEAD" | "IGNORE_CASE" | identifier // TODO "static" ?
//      "LOOKAHEAD" "=" INTEGER_LITERAL ";"
//	| 	"CHOICE_AMBIGUITY_CHECK" "=" INTEGER_LITERAL ";"
//	| 	"OTHER_AMBIGUITY_CHECK" "=" INTEGER_LITERAL ";"
//	| 	"AUTOMATIC_ERROR_RECOVERY" "=" java_boolean_literal ";"
//	| 	"STATIC" "=" java_boolean_literal ";"
//	| 	"SUPPORT_CLASS_VISIBILITY_PUBLIC" "=" java_boolean_literal ";"
//	| 	"DEBUG_PARSER" "=" java_boolean_literal ";"
//	| 	"DEBUG_LOOKAHEAD" "=" java_boolean_literal ";"
//	| 	"DEBUG_TOKEN_MANAGER" "=" java_boolean_literal ";"
//	| 	"ERROR_REPORTING" "=" java_boolean_literal ";"
//	| 	"JAVA_UNICODE_ESCAPE" "=" java_boolean_literal ";"
//	| 	"UNICODE_INPUT" "=" java_boolean_literal ";"
//	| 	"IGNORE_CASE" "=" java_boolean_literal ";"
//	| 	"USER_TOKEN_MANAGER" "=" java_boolean_literal ";"
//	| 	"USER_CHAR_STREAM" "=" java_boolean_literal ";"
//	| 	"BUILD_PARSER" "=" java_boolean_literal ";"
//	| 	"BUILD_TOKEN_MANAGER" "=" java_boolean_literal ";"
//	| 	"TOKEN_EXTENDS" "=" string_literal ";"
//	| 	"TOKEN_FACTORY" "=" string_literal ";"
//	| 	"TOKEN_MANAGER_USES_PARSER" "=" java_boolean_literal ";"
//	| 	"SANITY_CHECK" "=" java_boolean_literal ";"
//	| 	"FORCE_LA_CHECK" "=" java_boolean_literal ";"
//	| 	"COMMON_TOKEN_ACTION" "=" java_boolean_literal ";"
//	| 	"CACHE_TOKENS" "=" java_boolean_literal ";"
//	| 	"NODE_DEFAULT_VOID" "=" java_boolean_literal ";"
//	| 	"OUTPUT_DIRECTORY" "=" string_literal ";"


parser_declaration  ::=
    "PARSER_BEGIN" "(" identifier ")"
    java_compilation_unit // TODO inject Java here
    "PARSER_END" "(" identifier ")"
    {pin=1}

private production  ::=
        javacode_production
    | 	bnf_production
	| 	regular_expr_production
	| 	token_manager_decls

javacode_production ::=
        "JAVACODE"
		java_non_terminal_production_header [ jjtree_node_descriptor ]
		java_block
		{pin=2}

bnf_production 	    ::=
        java_non_terminal_production_header [ jjtree_node_descriptor ] ":"
		java_block
		"{" expansion_choices "}"
		{pin=1}


java_non_terminal_production_header  ::=  // TODO inject java here
        java_access_modifier
        java_return_type
        identifier
        "(" java_parameter_list ")"
        [ java_throws_list ]
        {pin=3}


java_throws_list ::=
        "throws" java_name ("," java_name)*


jjtree_node_descriptor      ::=
    "#" ( identifier | "void" )
    [ "(" jjtree_node_descriptor_expr ")" ]
//    {pin=1}

jjtree_node_descriptor_expr ::=
    [ ">" ] // GT-expression
    java_expression  // Is integer valued for definite nodes, is boolean valued for conditional nodes


token_manager_decls ::=
        "TOKEN_MGR_DECLS" ":" java_block  {pin=1} // TODO inject java here

regular_expr_production 	::=
        [ lexical_state_list ]
		regexpr_kind [ "[" "IGNORE_CASE" "]" ] ":"
		"{" regexpr_spec_list "}"
		{pin="regexpr_kind"}

private regexpr_spec_list   ::=
    regexpr_spec ( "|" regexpr_spec )*
	{pin(".*")=1}


lexical_state_list 	::=
        "<" "*" ">"
	| 	"<" identifier ( "," identifier )* ">"

regexpr_kind 	    ::=
        "TOKEN"
	| 	"SPECIAL_TOKEN"
	| 	"SKIP"
	| 	"MORE"

regexpr_spec 	    ::=
    priv_regular_expression [ java_block ] [ ":" identifier ] {
        methods=[lexicalState="identifier" regexp_unit=""]
        recoverWhile="#auto"
    }

fake expansion ::=

private expansion_choices 	        ::=
        expansion_alternative
    |   expansion_sequence

expansion_alternative       ::=
    expansion_sequence ( "|" expansion_sequence )+

expansion_sequence 	        ::=
    ( priv_expansion_unit jjtree_node_descriptor? )+ {pin=1}


private priv_expansion_unit 	            ::=
    (   local_lookahead
	| 	parser_actions_unit
	| 	parenthesized_expansion_unit
	| 	optional_expansion_unit
	|   try_catch_expansion_unit
	|   assigned_expansion_unit
	|   priv_regular_expression
	|   non_terminal_expansion_unit
    ) {recoverWhile="#auto" methods=[expansion_unit="" literal_regular_expression="" regular_expression_reference=""]}

parser_actions_unit     ::=
    java_block

assigned_expansion_unit ::=
    java_assignment_lhs "=" (priv_regular_expression | non_terminal_expansion_unit)
    {methods=[regexpUnitList=""]}

local_lookahead 	::=
    "LOOKAHEAD" "(" local_lookahead_tail ")" {pin=1}


private local_lookahead_tail    ::=
    // java_expression takes precedence over expansion_choices
    INTEGER_LITERAL [ "," "{" java_expression "}" ]
    | "{" java_expression "}"
    | [ INTEGER_LITERAL "," ] expansion_choices [ "," "{" java_expression "}" ]

non_terminal_expansion_unit     ::=
    identifier "(" java_expression_list ")" {pin=1}

parenthesized_expansion_unit    ::=
    "(" expansion_choices ")" [ one_or_more | zero_or_more | zero_or_one ]  {pin=1}

optional_expansion_unit         ::=
    "[" expansion_choices "]"
    {pin=1}

try_catch_expansion_unit        ::=
    "try" "{" [ expansion_choices ] "}"
    (catch_clause)*
    finally_clause?
    {pin="try"}

catch_clause                     ::=
    "catch" "(" java_name identifier ")" java_block

finally_clause                  ::=
    "finally" java_block

/* Regular expressions */

private priv_regular_expression	::=
        literal_regular_expression
    |   eof_regular_expression
    // Pins try to match these in order to allow autocompletion
    // If       ("<" IDENT ":") -> named regex
    // Else if  ("<" IDENT)     -> reference (autocomplete)
    // Else if  "<"             -> inline regex
	|   named_regular_expression
	|   regular_expression_reference
	|   inline_regular_expression
	{methods=[named_regular_expression=""]}

literal_regular_expression      ::=
    string_literal

eof_regular_expression          ::=
	"<" "EOF" ">"

named_regular_expression        ::=
	"<" [ "#" ] identifier ":" complex_regexp_choices ">"
    {pin=":"}

regular_expression_reference    ::=
	"<" identifier ">"
    {pin=identifier}

inline_regular_expression       ::=
	"<" complex_regexp_choices ">"
	{pin=1}


private complex_regexp_choices 	::=
        regexp_alternative
    |   regexp_sequence

regexp_alternative 	            ::=
    regexp_sequence ( "|" regexp_sequence )+

regexp_sequence                 ::=
    priv_regexp_unit+ {pin('.*')=1}

private priv_regexp_unit 	                ::=
        literal_regular_expression
	| 	regular_expression_reference
	| 	character_list
	| 	parenthesized_regexp_unit

parenthesized_regexp_unit       ::=
    "(" complex_regexp_choices ")" [ one_or_more | zero_or_more | zero_or_one | repetition_range ]

character_list                  ::=
    [ "~" ] "[" [ character_descriptor ( "," character_descriptor )* ] "]" {pin="["}

character_descriptor 	        ::=
    STRING_LITERAL [ "-" STRING_LITERAL ]
    {pin=1 recoverWhile="#auto"}

// Occurrence indicators

one_or_more                     ::= "+"
zero_or_more                    ::= "*"
zero_or_one                     ::= "?"
repetition_range                ::= "{" INTEGER_LITERAL [ "," INTEGER_LITERAL ] "}" {pin=1}

// Meta and fake rules

meta comma_separated_list       ::= [ <<param>> ( ',' <<param>> )* ]

fake identifier_owner           ::= identifier {
    methods=[nameIdentifier="identifier"]
    implements="com.intellij.psi.PsiNameIdentifierOwner"
}

fake non_terminal_production    ::= java_non_terminal_production_header [jjtree_node_descriptor] java_block {
    methods=[header="java_non_terminal_production_header"]
}

fake occurrence_indicator        ::=
fake occurrence_indicator_or_range  ::=
fake regular_expression         ::=
fake regexp_element             ::=
fake regexp_like                ::=
fake regexp_unit                ::=

fake expansion_unit             ::=

// Some java grammar

identifier                      ::=    IDENT                {name="identifier"}
private string_literal          ::=    STRING_LITERAL       {name="string literal"}


boolean_literal                 ::=    "true" | "false"

java_name                       ::=    identifier ("." identifier)* {pin=1}

java_return_type                ::=    "void" | java_type
private java_type               ::=    (PRIMITIVE_TYPE | java_coi_type) ("[" "]")*
private java_coi_type           ::=    java_name  // FIXME generics

java_access_modifier            ::=    [ "public" | "protected" | "private" ]

java_expression_list            ::=    <<comma_separated_list java_expression>>
private java_parameter_list     ::=    [ java_formal_parameter [ ("," java_formal_parameter)* ] ]
java_formal_parameter           ::=    java_type ["..."] identifier ("[" "]")*

// externals

java_compilation_unit               ::=     ext_java_compilation_unit
external ext_java_compilation_unit  ::=     parseJCompilationUnit

java_block                          ::=     "{" ext_java_block
external ext_java_block             ::=     parseJBlock

java_assignment_lhs                 ::=     ext_java_assignment_lhs
private ext_java_assignment_lhs     ::=     java_name   // FIXME only handles field accesses

java_expression                     ::=     ext_java_expression
external ext_java_expression        ::=     parseJExpression
