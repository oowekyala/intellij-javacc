package com.github.oowekyala.ijcc.ide.quickdoc

import com.github.oowekyala.ijcc.lang.model.GenericOption
import com.github.oowekyala.ijcc.lang.model.InlineGrammarOptions
import com.github.oowekyala.ijcc.lang.model.Token
import com.github.oowekyala.ijcc.lang.model.allOptionsBindings
import com.github.oowekyala.ijcc.lang.psi.JccFile
import com.github.oowekyala.ijcc.lang.psi.JccNonTerminalProduction
import com.github.oowekyala.ijcc.lang.psi.JccOptionBinding
import com.github.oowekyala.ijcc.lang.psi.getProductionByName
import com.github.oowekyala.ijcc.util.ResourcePrefix
import com.intellij.codeInsight.javadoc.JavaDocUtil
import com.intellij.lang.documentation.DocumentationMarkup.*
import com.intellij.openapi.util.Key
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiManager
import com.intellij.psi.impl.FakePsiElement
import org.jetbrains.annotations.TestOnly
import java.io.IOException

/**
 * Utilities to build the quickdoc.
 *
 * @author ClÃ©ment Fournier
 * @since 1.0
 */
object JccDocUtil {

    private const val TerminalRef = "token"
    private const val LexStateRef = "lexstate"
    private const val StringTokenRef = "strToken"
    private const val NonterminalRef = "nonterminal"
    private const val OptionRef = "option"

    /** Finds the target of a link created by [linkRefToLexicalState]. */
    fun findLinkTarget(psiManager: PsiManager?, ref: String?, context: PsiElement?): PsiElement? {
        ref ?: return null

        if (ref.contains('/')) {
            // the link was generated by this object

            val psiFile = context?.containingFile as? JccFile ?: return null
            val (type, name) = ref.split("/")


            return when (type) {
                LexStateRef    ->
                    psiFile.lexicalGrammar.getLexicalState(name)?.declarationIdent ?: psiFile.fakeDefaultStateDecl
                StringTokenRef -> psiFile.lexicalGrammar.allTokens.getOrNull(name.toInt())?.psiElement
                TerminalRef    -> psiFile.lexicalGrammar.getTokenByName(name)?.psiElement
                NonterminalRef -> psiFile.getProductionByName(name)
                OptionRef      -> psiFile.realOrFakeOptionNodeFor(name)
                else           -> null
            }
        } else {
            // probably generated by [JavaDocUtil]

            return JavaDocUtil.findReferenceTarget(psiManager, ref, context)
        }
    }

    fun linkRefToOption(name: String?) = "$OptionRef/$name"

    @TestOnly
    fun linkRefToStringToken(i: Int) = "$StringTokenRef/$i"

    /** Gets a hyperlink suitable for use with [HtmlUtil.psiLink]. */
    fun linkRefToToken(spec: Token): String? = when {
        spec.name != null -> "$TerminalRef/${spec.name}"
        else              ->
            spec.psiElement
                ?.containingFile
                ?.lexicalGrammar
                ?.allTokens
                ?.indexOf(spec)
                ?.let { "$StringTokenRef/$it" }
    }

    /** Gets a hyperlink suitable for use with [HtmlUtil.psiLink]. */
    fun linkRefToLexicalState(lexicalStateName: String): String = "$LexStateRef/$lexicalStateName"

    /** Gets a hyperlink suitable for use with [HtmlUtil.psiLink]. */
    fun linkRefToProd(production: JccNonTerminalProduction): String = "$NonterminalRef/${production.name}"


    /** Builds a quickdoc using a DSL, hiding most HTML formatting away. */
    fun buildQuickDoc(spec: DocBuilder.() -> Unit): String = StringBuilder().also { DocBuilder(it).spec() }.toString()

    class DocBuilder(private val stringBuilder: StringBuilder) {

        fun definition(defContents: () -> String): Unit =
            buildDefinition {
                append(defContents())
            }


        fun buildDefinition(defContents: java.lang.StringBuilder.() -> Unit) {
            stringBuilder.append(DEFINITION_START)
            stringBuilder.defContents()
            stringBuilder.append(DEFINITION_END).append("\n")
        }

        fun sections(sectionDefs: SectionsBuilder.() -> Unit) {
            stringBuilder.append(SECTIONS_START)
            SectionsBuilder(stringBuilder).sectionDefs()
            stringBuilder.append(SECTIONS_END)
        }

        fun freeHtml(text: () -> String) {
            stringBuilder.append(CONTENT_START)
            stringBuilder.append(text())
            stringBuilder.append(CONTENT_END)
        }

    }

    class SectionsBuilder(private val stringBuilder: StringBuilder) {

        fun emptySection(header: String): Unit = buildSection(header, sectionDelim = "") { }

        fun section(header: String, sectionDelim: String = ":", body: () -> String): Unit =
            buildSection(header, sectionDelim) {
                append(body())
            }

        fun buildSection(header: String, sectionDelim: String = ":", body: java.lang.StringBuilder.() -> Unit) {
            stringBuilder.append(SECTION_HEADER_START)
            stringBuilder.append(header).append(sectionDelim)
            stringBuilder.append(SECTION_SEPARATOR).append("<p>")
            stringBuilder.body()
            stringBuilder.append(SECTION_END).append("\n")
        }
    }
}


private val FakeDefaultStateEltKey = Key.create<PsiElement>("jcc.fake.default.state")
// Keys use reference identity so we must use a map within
private val FakeOptionEltsKey = Key.create<MutableMap<String, PsiElement>>("jcc.fake.option.elts")

/**
 * When the default state is not mentioned anywhere (eg in a <DEFAULT, FOO> lex
 * state declaration), we need a psi element for documentation links to resolve
 * to something (their target may only be a psi element).
 */
val JccFile.fakeDefaultStateDecl: PsiElement
    get() = getUserData(FakeDefaultStateEltKey)
        ?: let {
            val fake = object : FakePsiElement() {
                override fun getParent(): PsiElement = this@fakeDefaultStateDecl
            }
            putUserData(FakeDefaultStateEltKey, fake)

            return fake
        }

/**
 * Marker for fake option elements. See [realOrFakeOptionNodeFor]
 */
interface FakeOptionElt {
    val genericOption : GenericOption<*>
}


/**
 * Returns the element corresponding to the given option name.
 * - If the name is not the name of a know option, returns null
 * - Else if the option is set explicitly in the file, the
 *   [JccOptionBinding] is returned
 * - Else a fake element implementing [FakeOptionElt] is returned
 */
fun JccFile.realOrFakeOptionNodeFor(optionName: String): PsiElement? {

    val option = InlineGrammarOptions.knownOptions[optionName] ?: return null

    val real = allOptionsBindings.firstOrNull { it.name == optionName }
    if (real != null) return real

    val fakes = getUserData(FakeOptionEltsKey) ?: let {
        val data = mutableMapOf<String, PsiElement>()
        putUserData(FakeOptionEltsKey, data)
        data
    }

    return fakes.computeIfAbsent(optionName) {
        object : FakePsiElement(), FakeOptionElt {
            override fun getParent(): PsiElement = this@realOrFakeOptionNodeFor

            override val genericOption: GenericOption<*> = option
        }
    }
}

private val OptionDocCache = mutableMapOf<GenericOption<*>, String?>()

/**
 * Returns the documentable description of the option if it could be found.
 */
val GenericOption<*>.description: String?
    get()  = OptionDocCache.computeIfAbsent(this) { option->

        // link options between them
        fun String.escapeMarkup(): String =
            replace(OptionLinkRegex) {
                val name = it.groupValues[1]
                HtmlUtil.psiLink(linkTarget = JccDocUtil.linkRefToOption(name), linkText = name)
            }

        try {
            // try jjtree first
            val resource = JccDocUtil::class.java.getResource("$ResourcePrefix/optionDescriptions/jjtree/${option.name}.html")
                ?: JccDocUtil::class.java.getResource("$ResourcePrefix/optionDescriptions/${option.name}.html")

            resource?.readText()?.escapeMarkup()
        } catch (e: IOException) {
            null
        }
    }

private val OptionLinkRegex = Regex("""\{\s*option_link\s*(\w+)\s*}""")
