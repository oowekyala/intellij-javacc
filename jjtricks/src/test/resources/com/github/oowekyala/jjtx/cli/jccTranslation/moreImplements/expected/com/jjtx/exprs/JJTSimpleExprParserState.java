/*
 * Generated by JJTricks at Thu Jan 01 01:00:00 CET 1970
 * Not intended for manual editing.
 */

package com.jjtx.exprs;

import com.jjtx.exprs.ASTNode;
import java.util.Stack;

public class JJTSimpleExprParserState {
  private final Stack<ASTNode> nodes = new Stack<ASTNode>();
  private final Stack<Integer> marks = new Stack<Integer>();

  /**
   * Index of the first child of this node. If equal to {@link #nodes.size()}, no children are
   * pushed.
   */
  private int mk = 0;

  private boolean nodeCreated;

  /**
   * Returns true if the current node was closed and pushed (in case it was conditional). Reset as
   * soon as another node scope is opened.
   */
  public boolean nodeCreated() {
    return nodeCreated;
  }

  /**
   * Returns the root node of the AST. It only makes sense to call this after a successful parse.
   */
  public ASTNode rootNode() {
    return nodes.get(0);
  }

  /** Pushes a new node on to the stack. */
  public void pushNode(ASTNode n) {
    nodes.push(n);
  }

  /** Returns the node on the top of the stack, and remove it from the stack. */
  public ASTNode popNode() {
    if (nodes.size() - 1 < mk) {
      mk = marks.pop();
    }
    return nodes.pop();
  }

  /** Returns the node currently on the top of the stack. */
  public ASTNode peekNode() {
    return nodes.peek();
  }

  /** Returns the number of children on the stack in the current node scope. */
  public int nodeArity() {
    return nodes.size() - mk;
  }

  /** Abandon building the current node. */
  public void clearNodeScope(ASTNode n) {
    while (nodes.size() > mk) {
      popNode();
    }
    mk = marks.pop();
  }

  /** Start construction of the given node. */
  public void openNodeScope(ASTNode n) {
    marks.push(mk);
    mk = nodes.size();
    n.jjtOpen();
  }

  /**
   * A definite node is constructed from a specified number of children. That number of nodes are
   * popped from the stack and made the children of the definite node. Then the definite node is
   * pushed on to the stack.
   */
  public void closeNodeScope(ASTNode n, int num) {
    mk = marks.pop();
    while (num-- > 0) {
      ASTNode c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    nodeCreated = true;
  }

  /**
   * A conditional node is constructed if its condition is true. All the nodes that have been pushed
   * since the node was opened are made children of the conditional node, which is then pushed on to
   * the stack. If the condition is false the node is not constructed and they are left on the
   * stack.
   */
  public void closeNodeScope(ASTNode n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = marks.pop();
      while (a-- > 0) {
        ASTNode c = popNode();
        c.jjtSetParent(n);
        n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      nodeCreated = true;
    } else {
      mk = marks.pop();
      nodeCreated = false;
    }
  }
}