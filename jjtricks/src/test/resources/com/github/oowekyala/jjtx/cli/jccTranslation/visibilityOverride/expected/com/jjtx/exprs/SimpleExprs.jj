options {
    // MULTI = true;
    SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
}

PARSER_BEGIN(SimpleExprParser)

    package com.jjtx.exprs;
    import org.exprs.ast.*;


    /**
     *  This is my parser declaration
     */
    public class SimpleExprParser/*@bgen(jjtree)*/implements SimpleExprParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
    protected final org.exprs.ast.JJTSimpleExprParserState jjtree = new org.exprs.ast.JJTSimpleExprParserState();/*@egen*/

    }

PARSER_END(SimpleExprParser)

// Some token declarations
<DEFAULT>
TOKEN :{
  < PLUS: "+" >
| < MINUS: "-" >
| < NULL: "null" >
| < INTEGER: ["+",  "-"] <DIGITS> >
| < #DIGITS: (["0"-"9"])+ >
}


void Expression() :
{
    jjtThis.setImage("Expr"); // Do it
}
{
      BinaryExpression()
    | /*@bgen(jjtree) NullLiteral */
{
    ExNullLiteral nullLiteral = new ExNullLiteral(JJTNULLLITERAL);
    boolean nullLiteralNeedsClose = true;
    jjtree.openNodeScope(nullLiteral);
} try {
    /*@egen*/<NULL>
    /*@bgen(jjtree)*/
} catch (Throwable nullLiteralException) {
    if (nullLiteralNeedsClose) {
        jjtree.closeNodeScope(nullLiteral, true);
        nullLiteralNeedsClose = false;
    } else {
        jjtree.popNode();
    }
    // This chain of casts is meant to force you to declare
    // checked exceptions explicitly on the productions, else it fails
    // with a ClassCastException on the Error branch
    if (nullLiteralException instanceof ParseException) throw (ParseException) nullLiteralException;
    if (nullLiteralException instanceof RuntimeException) throw (RuntimeException) nullLiteralException;
    throw (Error) nullLiteralException;
} finally {
    if (nullLiteralNeedsClose) {
        jjtree.closeNodeScope(nullLiteral, true);
    }
}
/*@egen*/

}

ASTBinaryExpr BinaryExpression(): {
    /*@bgen(jjtree) BinaryExpr */
    ExBinaryExpr binaryExpr = new ExBinaryExpr(JJTBINARYEXPR);
    boolean binaryExprNeedsClose = true;
    jjtree.openNodeScope(binaryExpr);
    /*@egen*/
        binaryExpr.setImage("Expr"); // Do it
}
{
    /*@bgen(jjtree) BinaryExpr */
     try {
        /*@egen*/UnaryExpr() {binaryExpr.foo();} [ ( "+" | "-" ) UnaryExpr(binaryExpr) ]
    { return binaryExpr; }
        /*@bgen(jjtree)*/
    } catch (Throwable binaryExprException) {
        if (binaryExprNeedsClose) {
            jjtree.closeNodeScope(binaryExpr, jjtree.nodeArity() > 1);
            binaryExprNeedsClose = false;
        } else {
            jjtree.popNode();
        }
        // This chain of casts is meant to force you to declare
        // checked exceptions explicitly on the productions, else it fails
        // with a ClassCastException on the Error branch
        if (binaryExprException instanceof ParseException) throw (ParseException) binaryExprException;
        if (binaryExprException instanceof RuntimeException) throw (RuntimeException) binaryExprException;
        throw (Error) binaryExprException;
    } finally {
        if (binaryExprNeedsClose) {
            jjtree.closeNodeScope(binaryExpr, jjtree.nodeArity() > 1);
        }
    }
    /*@egen*/
}


void UnaryExpr() : {}
{
  /*@bgen(jjtree) ParenthesizedExpr */
{
    ExParenthesizedExpr parenthesizedExpr = new ExParenthesizedExpr(JJTPARENTHESIZEDEXPR);
    boolean parenthesizedExprNeedsClose = true;
    jjtree.openNodeScope(parenthesizedExpr);
} try {
    /*@egen*/("(" Expression() ")" {jjtThisManRocks.foo();} {parenthesizedExpr.foo();} )
    /*@bgen(jjtree)*/
} catch (Throwable parenthesizedExprException) {
    if (parenthesizedExprNeedsClose) {
        jjtree.closeNodeScope(parenthesizedExpr, true);
        parenthesizedExprNeedsClose = false;
    } else {
        jjtree.popNode();
    }
    // This chain of casts is meant to force you to declare
    // checked exceptions explicitly on the productions, else it fails
    // with a ClassCastException on the Error branch
    if (parenthesizedExprException instanceof ParseException) throw (ParseException) parenthesizedExprException;
    if (parenthesizedExprException instanceof RuntimeException) throw (RuntimeException) parenthesizedExprException;
    throw (Error) parenthesizedExprException;
} finally {
    if (parenthesizedExprNeedsClose) {
        jjtree.closeNodeScope(parenthesizedExpr, true);
    }
}
/*@egen*/
 {jjtThis.foo();} | Integer()
}

void Integer(): {
    /*@bgen(jjtree) IntegerLiteral */
    ExIntegerLiteral integerLiteral = new ExIntegerLiteral(JJTINTEGERLITERAL);
    boolean integerLiteralNeedsClose = true;
    jjtree.openNodeScope(integerLiteral);
    /*@egen*/
    
}
{
    /*@bgen(jjtree) IntegerLiteral */
     try {
        /*@egen*/<INTEGER>
        /*@bgen(jjtree)*/
    } catch (Throwable integerLiteralException) {
        if (integerLiteralNeedsClose) {
            jjtree.closeNodeScope(integerLiteral, true);
            integerLiteralNeedsClose = false;
        } else {
            jjtree.popNode();
        }
        // This chain of casts is meant to force you to declare
        // checked exceptions explicitly on the productions, else it fails
        // with a ClassCastException on the Error branch
        if (integerLiteralException instanceof ParseException) throw (ParseException) integerLiteralException;
        if (integerLiteralException instanceof RuntimeException) throw (RuntimeException) integerLiteralException;
        throw (Error) integerLiteralException;
    } finally {
        if (integerLiteralNeedsClose) {
            jjtree.closeNodeScope(integerLiteral, true);
        }
    }
    /*@egen*/
}