options {
    // MULTI = true;
    // NODE_PACKAGE = "com.exprs.ast";
}

PARSER_BEGIN(SimpleExprParser)

    package com.jjtx.exprs;
    import com.exprs.ast.*;
    import static com.jjtx.exprs.SimpleExprParserTreeConstants.*;


    /**
     *  This is my parser declaration
     */
    public class SimpleExprParser extends Foo<B> implements A {/*@bgen(jjtree)*/
    protected final com.exprs.ast.JJTSimpleExprParserState jjtree = new com.exprs.ast.JJTSimpleExprParserState();/*@egen*/

    }

PARSER_END(SimpleExprParser)

// Some token declarations
<DEFAULT>
TOKEN :{
  < PLUS: "+" >
| < MINUS: "-" >
| < NULL: "null" >
| < INTEGER: ["+",  "-"] <DIGITS> >
| < #DIGITS: (["0"-"9"])+ >
}


void Expression() : {}
{
      BinaryExpression()
    | /*@bgen(jjtree) NullLiteral */
{
    ExNullLiteral nullLiteral = new ExNullLiteral(JJTNULLLITERAL);
    boolean nullLiteralNeedsClose = true;
    jjtree.openNodeScope(nullLiteral);
} try {
    /*@egen*/ <NULL>
    /*@bgen(jjtree)*/
} catch (Throwable nullLiteralException) {
    if (nullLiteralNeedsClose) {
        jjtree.closeNodeScope(nullLiteral, true);
        nullLiteralNeedsClose = false;
    } else {
        jjtree.popNode();
    }
    // This chain of casts is meant to force you to declare
    // checked exceptions explicitly on the productions, else it fails
    // with a ClassCastException on the Error branch
    if (nullLiteralException instanceof ParseException) throw (ParseException) nullLiteralException;
    if (nullLiteralException instanceof RuntimeException) throw (RuntimeException) nullLiteralException;
    throw (Error) nullLiteralException;
} finally {
    if (nullLiteralNeedsClose) {
        jjtree.closeNodeScope(nullLiteral, true);
    }
}
/*@egen*/

}

void BinaryExpression(): {
    /*@bgen(jjtree) BinaryExpr */
    ExBinaryExpr binaryExpr = new ExBinaryExpr(JJTBINARYEXPR);
    boolean binaryExprNeedsClose = true;
    jjtree.openNodeScope(binaryExpr);
    /*@egen*/

}
{
    /*@bgen(jjtree) BinaryExpr */
     try {
        /*@egen*/ UnaryExpr() [ ( "+" | "-" ) UnaryExpr() ]
        /*@bgen(jjtree)*/
    } catch (Throwable binaryExprException) {
        if (binaryExprNeedsClose) {
            jjtree.closeNodeScope(binaryExpr, binaryExpr.foo());
            binaryExprNeedsClose = false;
        } else {
            jjtree.popNode();
        }
        // This chain of casts is meant to force you to declare
        // checked exceptions explicitly on the productions, else it fails
        // with a ClassCastException on the Error branch
        if (binaryExprException instanceof ParseException) throw (ParseException) binaryExprException;
        if (binaryExprException instanceof RuntimeException) throw (RuntimeException) binaryExprException;
        throw (Error) binaryExprException;
    } finally {
        if (binaryExprNeedsClose) {
            jjtree.closeNodeScope(binaryExpr, binaryExpr.foo());
        }
    }
    /*@egen*/
}


void UnaryExpr() : {}
{
  /*@bgen(jjtree) ParenthesizedExpr */
{
    ExParenthesizedExpr parenthesizedExpr = new ExParenthesizedExpr(JJTPARENTHESIZEDEXPR);
    boolean parenthesizedExprNeedsClose = true;
    jjtree.openNodeScope(parenthesizedExpr);
} try {
    /*@egen*/ ("(" Expression() ")")
    /*@bgen(jjtree)*/
} catch (Throwable parenthesizedExprException) {
    if (parenthesizedExprNeedsClose) {
        jjtree.closeNodeScope(parenthesizedExpr, parenthesizedExpr.numChildren() > 1);
        parenthesizedExprNeedsClose = false;
    } else {
        jjtree.popNode();
    }
    // This chain of casts is meant to force you to declare
    // checked exceptions explicitly on the productions, else it fails
    // with a ClassCastException on the Error branch
    if (parenthesizedExprException instanceof ParseException) throw (ParseException) parenthesizedExprException;
    if (parenthesizedExprException instanceof RuntimeException) throw (RuntimeException) parenthesizedExprException;
    throw (Error) parenthesizedExprException;
} finally {
    if (parenthesizedExprNeedsClose) {
        jjtree.closeNodeScope(parenthesizedExpr, parenthesizedExpr.numChildren() > 1);
    }
}
/*@egen*/
 | Integer()
}

void Integer(): {
    /*@bgen(jjtree) IntegerLiteral */
    ExIntegerLiteral integerLiteral = new ExIntegerLiteral(JJTINTEGERLITERAL);
    boolean integerLiteralNeedsClose = true;
    jjtree.openNodeScope(integerLiteral);
    /*@egen*/

}
{
    /*@bgen(jjtree) IntegerLiteral */
     try {
        /*@egen*/ <INTEGER>
        /*@bgen(jjtree)*/
    } catch (Throwable integerLiteralException) {
        if (integerLiteralNeedsClose) {
            jjtree.closeNodeScope(integerLiteral, true);
            integerLiteralNeedsClose = false;
        } else {
            jjtree.popNode();
        }
        // This chain of casts is meant to force you to declare
        // checked exceptions explicitly on the productions, else it fails
        // with a ClassCastException on the Error branch
        if (integerLiteralException instanceof ParseException) throw (ParseException) integerLiteralException;
        if (integerLiteralException instanceof RuntimeException) throw (RuntimeException) integerLiteralException;
        throw (Error) integerLiteralException;
    } finally {
        if (integerLiteralNeedsClose) {
            jjtree.closeNodeScope(integerLiteral, true);
        }
    }
    /*@egen*/
}