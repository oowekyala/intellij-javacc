#evaluate( $!fileHeader )

import $grammar.parser.class.qualifiedName;
import static ${run.javaccGen.support.nodeIds.class.qualifiedName}.*;
#if ($!grammar.optionsOfGrammarFile.NODE_FACTORY == "*" && "$!grammar.nodePackage" != "")
    import ${grammar.nodePackage}.*;
#end


/**
 * This class is responsible for creating new nodes from their ID.
 * The construction method is called by the parser each time a node
 * scope is opened.
 */
$!visibility $!modifiers class ${thisClass.simpleName} {

        private ${thisClass.simpleName}(){
        // static class
        }

#if ( $grammar.nodeTakesParserArg )
    #set ( $args = "(parser, id)")
#else
    #set ( $args = "(id)")
#end


    #if ( $grammar.nodeTakesParserArg )
        public static $topNode jjtCreate($grammar.parser.class.simpleName parser, $run.javaccGen.support.nodeIds.context.nodeIdType id){
    #else
        public static $topNode jjtCreate($run.javaccGen.support.nodeIds.context.nodeIdType id){
    #end

    #if ( "$!grammar.optionsOfGrammarFile.NODE_FACTORY" != ""
          && $!grammar.optionsOfGrammarFile.NODE_FACTORY != "*" )
         ## Simple security, normally if that's the case this file is not generated by default
         return $!{grammar.optionsOfGrammarFile.NODE_FACTORY}${args};
    #else
                switch(id){
        #foreach($node in $grammar.typeHierarchy)
                #if ( !$node.external )
                    case #evaluate( ${run.javaccGen.support.nodeIds.context.nodeIdTemplate} ):
                        #if ($!grammar.optionsOfGrammarFile.NODE_FACTORY == "*")
                                return $!{node.class.simpleName}.jjtCreate${args};
                        #else
                                return new ${node.class.simpleName}$args;
                        #end
                #end
        #end
        #foreach($node in $grammar.typeHierarchy)
            #if ( $node.external )
                case #evaluate( ${run.javaccGen.support.nodeIds.context.nodeIdTemplate} ):
            #end
            #if ($foreach.last)
                    // JJTricks doesn't know whether it's an interface or anything...
                    // The parser will never attempt to create nodes with those IDs though.
                    throw new IllegalArgumentException("Node " + id + " doesn't correspond to a production and can't be built by this default factory");
            #end
        #end
                default:
                    throw new IllegalArgumentException("Unknown node id " + id);
                }

    #end

    }

}
