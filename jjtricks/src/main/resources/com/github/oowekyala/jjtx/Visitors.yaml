shared:
  visitorMethodComment: |
    /**
     * Visits {@linkplain $node.class.simpleName $node.name}.
       #if ( $node.superNode )
     * Delegates to {@link $H#methodAnchor($node.superNode)}
     * if unimplemented.
     *
      #if ( !$node.subNodes.empty )
     * This method is delegated to by:
     * <ul>
        #foreach($sub in $node.subNodes)
     *   <li>{@link $H#methodAnchor($sub)}</li>
        #end
     * </ul>
      #end
      #else
     *   This is the root of the delegation chain.
      #end
     *
     */

defaultJjtreeVisitor:
  templateFile: "/jjtx/templates/VisitorInterface.java.vm"
  formatter: java
  genClassName: "${grammar.nodePackage}.${grammar.name}ParserVisitor"
  context:
    visibility: public
    visitorMethodComment: !from '#/shared/visitorMethodComment'
    methodTemplate: |
      #macro( methodAnchor $n)
      visit($n.class.simpleName,Object)
      #end

      #evaluate($visitorMethodComment)
      $!mods.default Object visit($node.class.simpleName node, Object data)
      #if ( $mods.default )
      {
          #if ($node.superNode)
          return visit(($node.superNode.class.simpleName) node, data);
          #else
          return node.childrenAccept(this, data);
          #end
      }
      #else
      ;
      #end
    acceptMethod: |
      @Override
      public Object jjtAccept($visitor.class.qualifiedName visitor, Object data) {
         return visitor.visit(this, data);
      }

parameterlessVisitor:
  templateFile: "/jjtx/templates/VisitorInterface.java.vm"
  genClassName: "${grammar.nodePackage}.${grammar.name}Visitor"
  formatter: java
  context:
    visibility: public
    visitorMethodComment: !from '#/shared/visitorMethodComment'
    methodTemplate: |
      #macro( methodAnchor $node)
      visit($node.class.simpleName)
      #end

      #evaluate($visitorMethodComment)
      $!mods.default void visit($node.class.simpleName node)
      #if ( $mods.default )
      {
          #if ($node.superNode)
          visit(($node.superNode.class.simpleName) node);
          #else
          node.childrenAccept(this);
          #end
      }
      #else
      ;
      #end
    acceptMethod: |
      @Override
      public void jjtAccept($visitor.class.qualifiedName visitor) {
         visitor.visit(this);
      }


genericVoidVisitor:
  templateFile: "/jjtx/templates/VisitorInterface.java.vm"
  genClassName: "${grammar.nodePackage}.${grammar.name}Visitor"
  formatter: java
  context:
    visibility: public
    visitorMethodComment: !from '#/shared/visitorMethodComment'
#    These are only needed if $recursive is set to true,
#    so not by default. If someone configures it to be recursive,
#    then I expect they'll plug-in the correct method names here
#    when they see the variables literally in the generated code.

#    nodeGetChildMethod: node.jjtGetChild(i)
#    nodeNumChildMethod: node.jjtGetNumChildren()
    visitTemplate: "visit"
    acceptMethodName: jjtAccept
    generics: "<T>"
    moreHeader: |
      #macro( methodAnchor $node)
      visit($node.class.simpleName)
      #end

      #macro( visitName $node)
      #evaluate( $visitTemplate )
      #end

    methodTemplate: |

      #evaluate($visitorMethodComment)
      $!mods.default void #visitName( $node )($node.class.simpleName node, T data)
      #if ( $mods.default )
      {
          #if ( $node.superNode )
            #visitName( $node.superNode ) (($node.superNode.class.simpleName) node, data);
          #elseif ( $recursive )
            for (int i = 0; i < $nodeNumChildMethod; i++)
              $nodeGetChildMethod .${acceptMethodName}(this, data);
          #else
            // Don't recurse by default
          #end
      }
      #else
      ;
      #end
    acceptMethod: |
      @Override
      public <T> void ${visitor.context.acceptMethodName}($visitor.class.qualifiedName<T> visitor, T data) {
         visitor.#evaluate( $visitor.context.visitTemplate )(this, data);
      }

