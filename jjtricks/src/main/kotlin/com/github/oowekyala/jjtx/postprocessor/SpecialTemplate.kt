package com.github.oowekyala.jjtx.postprocessor

import com.github.oowekyala.ijcc.lang.model.IGrammarOptions
import com.github.oowekyala.ijcc.lang.model.addNodePackage
import com.github.oowekyala.ijcc.lang.model.addParserPackage
import com.github.oowekyala.ijcc.lang.model.parserSimpleName
import com.github.oowekyala.jjtx.JjtxContext
import com.github.oowekyala.jjtx.JjtxOptsModel
import com.github.oowekyala.jjtx.templates.vbeans.ClassVBean


val JjtxContext.tokenClass: ClassVBean
    get() = SpecialTemplate.TOKEN.actualLocation(this.jjtxOptsModel)

/**
 * Special templates are the support files necessary for the parser to function.
 *
 * They are either generated by JavaCC, or by JJTricks. Configuration works the
 * same regardless of the way they're generated.
 */
enum class SpecialTemplate(val id: String,
                           val externalGenerated: Boolean,
                           private val defaultClassSimpleName: String = id.capitalize()) {

    // Those are all generated by JavaCC, but can be replaced

    TOKEN("token", true),
    TOKEN_MANAGER("tokenManager", true),
    CHAR_STREAM("charStream", true),
    /**
     * IDs of tokens, images of string tokens.
     */
    TOKEN_IDS("tokenIds", true) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean =
            ClassVBean(opts.addParserPackage(opts.parserSimpleName + "Constants"))
    },
    // This one is added by jjtricks
    TOKEN_FACTORY("tokenFactory", false),


    LEX_EXCEPTION("lexException", true) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean {
            val suffix = when (opts.inlineBindings.isLegacyGen) {
                true  -> "Error"
                false -> "Exception"
            }

            return ClassVBean(opts.addParserPackage("TokenMgr$suffix"))
        }

    },
    PARSE_EXCEPTION("parseException", true),

    // special templates relevant to tree building
    // Those are generated by VTL templating

    JJ_FILE("jjFile", true) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean =
            throw UnsupportedOperationException("JJ File special template has no default location")
    },

    TREE_BUILDER("treeBuilder", false) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean =
            ClassVBean(opts.addNodePackage("JJT" + opts.parserSimpleName + "State"))
    },
    NODE_MANIPULATOR("manipulator", false) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean =
            ClassVBean(opts.addNodePackage("NodeManipulator"))
    },
    NODE_FACTORY("nodeFactory", false) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean =
            ClassVBean(opts.addNodePackage(opts.grammarName.orEmpty().capitalize() + "NodeFactory"))
    },
    NODE_IDS("nodeIds", false) {
        override fun defaultLocation(opts: IGrammarOptions): ClassVBean =
            ClassVBean(opts.addNodePackage(opts.parserSimpleName + "TreeConstants"))
    },
    ;

    fun actualLocation(opts: IGrammarOptions): ClassVBean =
        (opts as? JjtxOptsModel)?.javaccGen?.supportFiles?.get(id)?.genFqcn?.let(::ClassVBean)
            ?: defaultLocation(opts)

    open fun defaultLocation(opts: IGrammarOptions) =
        ClassVBean(opts.addParserPackage(defaultClassSimpleName))


    companion object {

        fun findById(id: String): SpecialTemplate? = values().firstOrNull { it.id == id }

        val externalGen: List<SpecialTemplate> = values().filter { it.externalGenerated }

    }


}
